<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox Studio - Play</title>
<style>
  body { margin:0; overflow:hidden; background: #000; }
  #ui {
    position: fixed; top:20px; left:20px; color:#444;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: rgba(255, 255, 255, 0.9);
    padding:15px; border-radius:20px; z-index:10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="ui">
  üì¶üõ†Ô∏è **Funbox Launcher** (Mundo 500x500)<br>
  WASD: Moverse | **Shift: Correr** | **C: Cabeza** | **R: C√°mara**
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // Cielo azul

// 1. C√ÅMARA CONFIGURADA PARA VER A 1000 METROS
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ILUMINACI√ìN
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const light = new THREE.DirectionalLight(0xffffff, 0.6);
light.position.set(50, 100, 50);
light.castShadow = true;
scene.add(light);

// 2. SUELO CUADRADO GIGANTE (500x500)
const floorSize = 500; 
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(floorSize, floorSize), 
    new THREE.MeshStandardMaterial({color: 0x3a7d44}) // Verde pasto
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// 3. CARGAR BLOQUES DEL EDITOR
const mapData = JSON.parse(localStorage.getItem("funbox_map")) || [];
const blockGeo = new THREE.BoxGeometry(1, 1, 1);
const blockMat = new THREE.MeshStandardMaterial({color: 0x888888});

mapData.forEach(b => {
    const block = new THREE.Mesh(blockGeo, blockMat);
    // IMPORTANTE: b.x y b.y vienen del editor
    block.position.set(b.x, 0.5, b.y); 
    block.castShadow = true;
    block.receiveShadow = true;
    scene.add(block);
});

// --- PERSONAJE (TU DISE√ëO) ---
const player = new THREE.Group();
const cuerpoVisual = new THREE.Group();
player.add(cuerpoVisual);

const matPiel = new THREE.MeshStandardMaterial({color: 0xffdbac});
const matPelo = new THREE.MeshStandardMaterial({color: 0x4e342e}); 
const matRopa = new THREE.MeshStandardMaterial({color: 0x2196f3});
const matOjoNegro = new THREE.MeshBasicMaterial({color: 0x111111});

const cabezaGroup = new THREE.Group();
cabezaGroup.position.y = 0.75;
cuerpoVisual.add(cabezaGroup);

const cabezaMesh = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.5, 0.5), matPiel);
cabezaMesh.castShadow = true;
cabezaGroup.add(cabezaMesh);

const pelo = new THREE.Mesh(new THREE.BoxGeometry(0.58, 0.22, 0.52), matPelo);
pelo.position.y = 0.2; cabezaMesh.add(pelo);
const barba = new THREE.Mesh(new THREE.BoxGeometry(0.57, 0.15, 0.51), matPelo);
barba.position.y = -0.18; cabezaMesh.add(barba);

const listaOjos = [];
function crearOjo(x) {
    const ojoGroup = new THREE.Group();
    const pupila = new THREE.Mesh(new THREE.CircleGeometry(0.07, 32), matOjoNegro);
    const b1 = new THREE.Mesh(new THREE.CircleGeometry(0.022, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
    b1.position.set(0.025, 0.025, 0.001);
    ojoGroup.add(pupila, b1);
    ojoGroup.position.set(x, -0.02, 0.251);
    listaOjos.push(ojoGroup);
    return ojoGroup;
}
cabezaMesh.add(crearOjo(-0.18), crearOjo(0.18));

const cuerpoRef = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.2, 4, 12), matRopa);
cuerpoRef.position.y = 0.35; cuerpoVisual.add(cuerpoRef);

const brazoI = new THREE.Mesh(new THREE.SphereGeometry(0.065, 16, 16), matPiel);
brazoI.position.set(-0.3, 0.4, 0); cuerpoVisual.add(brazoI);
const brazoD = brazoI.clone();
brazoD.position.set(0.3, 0.4, 0); cuerpoVisual.add(brazoD);

const piernaI = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.1, 4, 8), new THREE.MeshStandardMaterial({color:0x333333}));
piernaI.position.set(-0.12, 0.1, 0); player.add(piernaI);
const piernaD = piernaI.clone();
piernaD.position.set(0.12, 0.1, 0); player.add(piernaD);

scene.add(player);

// --- L√ìGICA DE JUEGO ---
let vy = 0, onGround = true, isDead = false, isHeadMode = false;
const gravity = -0.012, jumpForce = 0.25;
const keys = {};
let yaw = 0, step = 0;

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if(e.code === "Space" && onGround) vy = jumpForce;
    if(e.key.toLowerCase() === "c") isHeadMode = !isHeadMode;
});
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });

function animate() {
    requestAnimationFrame(animate);
    player.position.y += vy;
    
    // CA√çDA FUERA DEL MAPA (500x500)
    const half = floorSize / 2;
    const outOfBounds = Math.abs(player.position.x) > half || Math.abs(player.position.z) > half;

    if (player.position.y > 0 || outOfBounds) {
        vy += gravity; onGround = false;
    } else {
        player.position.y = 0; vy = 0; onGround = true;
    }

    // Respawn si caes al vac√≠o
    if (player.position.y < -20) {
        player.position.set(0, 5, 0);
        vy = 0;
    }

    // MOVIMIENTO
    let moving = false, dir = new THREE.Vector3();
    if(keys.w){ dir.z -= 1; moving = true; }
    if(keys.s){ dir.z += 1; moving = true; }
    if(keys.a){ dir.x -= 1; moving = true; }
    if(keys.d){ dir.x += 1; moving = true; }

    let moveSpeed = keys.shift ? 0.18 : 0.1;
    player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, yaw + Math.PI, 0.1);

    if(moving) {
        const moveDir = dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        player.position.addScaledVector(moveDir, moveSpeed);
        if (!isHeadMode) {
            step += 0.2;
            piernaI.rotation.x = Math.sin(step) * 0.8;
            piernaD.rotation.x = Math.sin(step + Math.PI) * 0.8;
        } else {
            cabezaMesh.rotation.x -= 0.15;
        }
    }

    // TRANSFORMACI√ìN CABEZA
    cabezaGroup.position.y = THREE.MathUtils.lerp(cabezaGroup.position.y, isHeadMode ? 0.25 : 0.75, 0.1);
    cuerpoRef.scale.set(isHeadMode ? 0 : 1, isHeadMode ? 0 : 1, isHeadMode ? 0 : 1);

    // C√ÅMARA
    const camDist = isHeadMode ? 2.5 : 4;
    const camOffset = new THREE.Vector3(0, 2, camDist).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    camera.position.lerp(player.position.clone().add(camOffset), 0.1);
    camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 1, 0)));
    
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
