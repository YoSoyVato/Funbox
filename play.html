<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox Studio</title>
<style>
  body { margin:0; overflow:hidden; background: #000; }
  #ui {
    position: fixed; top:20px; left:20px; color:#444;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: rgba(255, 255, 255, 0.9);
    padding:15px; border-radius:20px; z-index:10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
</style>
</head>
<body>

<div id="ui">
  üì¶üõ†Ô∏è **Funbox Studio**<br>
  WASD: Moverse | **Shift: CORRER** | **C: Agacharse** | **R: C√°mara Frontal**
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// --- CARGAR CONFIGURACI√ìN ---
const config = JSON.parse(localStorage.getItem("funbox_config")) || { 
    floorColor: "#eeeeee", 
    floorSize: 500,
    skyColor: "#87ceeb", 
    ambientIntensity: 0.9 
};

const scene = new THREE.Scene();
scene.background = new THREE.Color(config.skyColor);

const fogDensity = config.skyColor === "#1a1a2e" ? 0.05 : 0.01;
scene.fog = new THREE.FogExp2(config.skyColor, fogDensity);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

const hemiLight = new THREE.HemisphereLight(config.skyColor, config.floorColor, 0.6);
scene.add(hemiLight);

const ambient = new THREE.AmbientLight(0xffffff, config.ambientIntensity * 0.5);
scene.add(ambient);

const sunLight = new THREE.DirectionalLight(0xffffff, config.ambientIntensity);
sunLight.position.set(50, 100, 50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);

const sunGeo = new THREE.SphereGeometry(10, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({
    color: config.skyColor === "#1a1a2e" ? 0xffffcc : 0xffffee 
});
const sunVisual = new THREE.Mesh(sunGeo, sunMat);
sunVisual.position.set(100, 150, -200);
scene.add(sunVisual);

const floorSize = config.floorSize; 
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(floorSize, floorSize), 
    new THREE.MeshStandardMaterial({
        color: config.floorColor,
        roughness: 0.8,
        metalness: 0.1
    })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// --- FUNCI√ìN PARA CREAR MUEBLES (BOXASSETS) ---
function createAssetMesh(type) {
    const group = new THREE.Group();
    const woodMat = new THREE.MeshStandardMaterial({color: 0x5d4037});
    const ironMat = new THREE.MeshStandardMaterial({color: 0x333333});
    
    if (type === 'chair') {
        const base = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.6), woodMat);
        base.position.y = 0.4;
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.1), woodMat);
        back.position.set(0, 0.75, -0.25);
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), woodMat);
        leg.position.y = 0.2;
        group.add(base, back, leg);
    } else if (type === 'table') {
        const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 1.2), woodMat);
        top.position.y = 0.8;
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), woodMat);
        leg.position.y = 0.4;
        group.add(top, leg);
    } else if (type === 'pc') {
        const monitor = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.05), ironMat);
        monitor.position.y = 0.3;
        const screen = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.35, 0.01), new THREE.MeshBasicMaterial({color: 0x00ffff}));
        screen.position.set(0, 0.3, 0.03);
        const base = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.2), ironMat);
        group.add(monitor, screen, base);
    } else if (type === 'bed') {
        const mattress = new THREE.Mesh(new THREE.BoxGeometry(1, 0.4, 1.8), new THREE.MeshStandardMaterial({color: 0xffffff}));
        mattress.position.y = 0.2;
        const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.4), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
        pillow.position.set(0, 0.45, -0.6);
        group.add(mattress, pillow);
    } else if (type === 'flashlight') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.4), ironMat);
        body.rotation.x = Math.PI/2;
        body.position.y = 0.2;
        const lens = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), new THREE.MeshBasicMaterial({color: 0xffff00}));
        lens.position.set(0, 0.2, 0.21);
        group.add(body, lens);
    }
    
    group.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
    return group;
}

// --- CARGA DE BLOQUES Y F√çSICA ---
const mapData = JSON.parse(localStorage.getItem("funbox_map")) || [];
const physicalBlocks = [];
const boxGeo = new THREE.BoxGeometry(1, 1, 1);
const spawnGeo = new THREE.BoxGeometry(1.2, 0.1, 1.2); 
const boxMat = new THREE.MeshStandardMaterial({color: 0x2196f3});
const spawnMat = new THREE.MeshStandardMaterial({
    color: 0xffffff, 
    emissive: 0xffffff, 
    emissiveIntensity: 0.4 
});

let spawnPoint = new THREE.Vector3(0, 0, 0);

mapData.forEach(b => {
    const isSpawn = b.type === "spawn";
    let block;

    if (isSpawn) {
        block = new THREE.Mesh(spawnGeo, spawnMat);
        block.position.set(b.x + 0.5, 0.05, b.y + 0.5);
        spawnPoint.set(block.position.x, 0, block.position.z);
    } else if (b.type === "block") {
        block = new THREE.Mesh(boxGeo, boxMat);
        block.position.set(b.x + 0.5, 0.5, b.y + 0.5);
        physicalBlocks.push(block);
    } else {
        // ES UN ASSET
        block = createAssetMesh(b.type);
        block.position.set(b.x + 0.5, 0, b.y + 0.5);
        // Creamos un hitbox invisible para el mueble
        const hitbox = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1, 0.9), new THREE.MeshBasicMaterial({visible: false}));
        hitbox.position.set(b.x + 0.5, 0.5, b.y + 0.5);
        physicalBlocks.push(hitbox);
    }
    
    block.castShadow = true;
    block.receiveShadow = true;
    scene.add(block);
});

// FUNCIONES DE COLISI√ìN
function getSurfaceY(pos) {
    let maxY = 0; 
    const pR = 0.3; 
    physicalBlocks.forEach(b => {
        if (Math.abs(pos.x - b.position.x) < 0.5 + pR && Math.abs(pos.z - b.position.z) < 0.5 + pR) {
            if (pos.y >= b.position.y + 0.4) maxY = Math.max(maxY, 1.0);
        }
    });
    return maxY;
}

function isColliding(pos) {
    const pR = 0.35;
    for (let b of physicalBlocks) {
        if (Math.abs(pos.y - b.position.y) < 0.5) {
            if (Math.abs(pos.x - b.position.x) < 0.5 + pR && Math.abs(pos.z - b.position.z) < 0.5 + pR) return true;
        }
    }
    return false;
}

// --- PERSONAJE ---
const player = new THREE.Group();
player.position.copy(spawnPoint); 
const cuerpoVisual = new THREE.Group();
player.add(cuerpoVisual);

const matPiel = new THREE.MeshStandardMaterial({color: 0xffdbac});
const matPelo = new THREE.MeshStandardMaterial({color: 0x4e342e}); 
const matRopa = new THREE.MeshStandardMaterial({color: 0x2196f3});
const matOjoNegro = new THREE.MeshBasicMaterial({color: 0x111111});

const cabezaGroup = new THREE.Group();
cabezaGroup.position.y = 0.75;
cuerpoVisual.add(cabezaGroup);

const cabezaMesh = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.5, 0.5), matPiel);
cabezaMesh.castShadow = true;
cabezaGroup.add(cabezaMesh);

const pelo = new THREE.Mesh(new THREE.BoxGeometry(0.58, 0.22, 0.52), matPelo);
pelo.position.y = 0.2; cabezaMesh.add(pelo);
const barba = new THREE.Mesh(new THREE.BoxGeometry(0.57, 0.15, 0.51), matPelo);
barba.position.y = -0.18; cabezaMesh.add(barba);

const listaOjos = [];
function crearOjo(x) {
    const ojoGroup = new THREE.Group();
    const pupila = new THREE.Mesh(new THREE.CircleGeometry(0.07, 32), matOjoNegro);
    const b1 = new THREE.Mesh(new THREE.CircleGeometry(0.022, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
    b1.position.set(0.025, 0.025, 0.001);
    const b2 = new THREE.Mesh(new THREE.CircleGeometry(0.01, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
    b2.position.set(-0.02, -0.02, 0.001);
    ojoGroup.add(pupila, b1, b2);
    ojoGroup.position.set(x, -0.02, 0.251);
    listaOjos.push(ojoGroup);
    return ojoGroup;
}
cabezaMesh.add(crearOjo(-0.18), crearOjo(0.18));

const cuerpoRef = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.2, 4, 12), matRopa);
cuerpoRef.position.y = 0.35; cuerpoVisual.add(cuerpoRef);

const brazoI = new THREE.Mesh(new THREE.SphereGeometry(0.065, 16, 16), matPiel);
brazoI.position.set(-0.3, 0.4, 0); cuerpoVisual.add(brazoI);
const brazoD = brazoI.clone();
brazoD.position.set(0.3, 0.4, 0); cuerpoVisual.add(brazoD);

const piernaI = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.1, 4, 8), new THREE.MeshStandardMaterial({color:0x333333}));
piernaI.position.set(-0.12, 0.1, 0); player.add(piernaI);
const piernaD = piernaI.clone();
piernaD.position.set(0.12, 0.1, 0); player.add(piernaD);

scene.add(player);

// --- L√ìGICA ---
let vy = 0, onGround = true, isDead = false, isHeadMode = false;
const gravity = -0.015, jumpForce = 0.3;
const keys = {};
let yaw = 0, step = 0, panicStep = 0;
let blinkTimer = 0;

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if(e.code === "Space" && onGround && !isDead) vy = jumpForce;
    if(e.key.toLowerCase() === "c" && onGround && !isDead) isHeadMode = !isHeadMode;
});
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });

function animate() {
    requestAnimationFrame(animate);

    const currentSurfaceY = getSurfaceY(player.position);
    player.position.y += vy;
    
    const half = floorSize / 2;
    const outOfBounds = Math.abs(player.position.x) > half || Math.abs(player.position.z) > half;

    if (player.position.y > currentSurfaceY || outOfBounds) {
        vy += gravity; onGround = false;
    } else if (!isDead) {
        player.position.y = currentSurfaceY; vy = 0; onGround = true;
    }

    if (player.position.y < -1) {
        isDead = true;
        panicStep += 0.5;
        brazoI.position.y = 0.4 + Math.sin(panicStep) * 0.2;
        brazoD.position.y = 0.4 + Math.cos(panicStep) * 0.2;
        piernaI.rotation.x = Math.sin(panicStep * 1.5) * 1;
        piernaD.rotation.x = Math.cos(panicStep * 1.5) * 1;
        
        if (player.position.y < -15) {
            player.position.copy(spawnPoint);
            player.position.y = 5;
            isDead = false; vy = 0; panicStep = 0;
            isHeadMode = false;
            brazoI.position.set(-0.3, 0.4, 0);
            brazoD.position.set(0.3, 0.4, 0);
        }
    }

    let moving = false, dir = new THREE.Vector3();
    if(!isDead) {
        if(keys.w){ dir.z -= 1; moving = true; }
        if(keys.s){ dir.z += 1; moving = true; }
        if(keys.a){ dir.x -= 1; moving = true; }
        if(keys.d){ dir.x += 1; moving = true; }
    }

    let moveSpeed = isHeadMode ? 0.12 : 0.09;
    let animationSpeed = 0.25;
    if (keys.shift && !isHeadMode) { moveSpeed = 0.18; animationSpeed = 0.45; }

    player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, yaw + Math.PI, 0.1);

    if(moving && !isDead) {
        const moveDir = dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        const nextX = player.position.clone(); nextX.x += moveDir.x * moveSpeed;
        if (!isColliding(nextX)) player.position.x = nextX.x;
        const nextZ = player.position.clone(); nextZ.z += moveDir.z * moveSpeed;
        if (!isColliding(nextZ)) player.position.z = nextZ.z;
        
        if (!isHeadMode && onGround) {
            step += animationSpeed;
            piernaI.rotation.x = Math.sin(step) * 0.8;
            piernaD.rotation.x = Math.sin(step + Math.PI) * 0.8;
            brazoI.position.z = Math.sin(step + Math.PI) * 0.15;
            brazoD.position.z = Math.sin(step) * 0.15;
        } else if (isHeadMode) {
            cabezaMesh.rotation.x -= 0.15; 
        }
    } else if (onGround && !isDead) {
        step = THREE.MathUtils.lerp(step, 0, 0.1);
        piernaI.rotation.x = THREE.MathUtils.lerp(piernaI.rotation.x, 0, 0.1);
        piernaD.rotation.x = THREE.MathUtils.lerp(piernaD.rotation.x, 0, 0.1);
        brazoI.position.z = THREE.MathUtils.lerp(brazoI.position.z, 0, 0.15);
        brazoD.position.z = THREE.MathUtils.lerp(brazoD.position.z, 0, 0.15);
        brazoI.position.y = THREE.MathUtils.lerp(brazoI.position.y, 0.4, 0.1);
        brazoD.position.y = THREE.MathUtils.lerp(brazoD.position.y, 0.4, 0.1);
    }

    const t = 0.15;
    if (isHeadMode && !isDead) {
        cuerpoRef.scale.set(THREE.MathUtils.lerp(cuerpoRef.scale.x, 0, t), 0, 0);
        brazoI.scale.set(0,0,0); brazoD.scale.set(0,0,0);
        piernaI.scale.set(0,0,0); piernaD.scale.set(0,0,0);
        cabezaGroup.position.y = THREE.MathUtils.lerp(cabezaGroup.position.y, 0.25, t);
    } else if (!isDead) {
        cuerpoRef.scale.set(1, 1, 1);
        brazoI.scale.set(1,1,1); brazoD.scale.set(1,1,1);
        piernaI.scale.set(1,1,1); piernaD.scale.set(1,1,1);
        cabezaGroup.position.y = THREE.MathUtils.lerp(cabezaGroup.position.y, 0.75, t);
        if(!moving) cabezaMesh.rotation.x = THREE.MathUtils.lerp(cabezaMesh.rotation.x, 0, t);
    }

    blinkTimer--;
    if (blinkTimer < 0) blinkTimer = Math.random() * 300 + 100;
    listaOjos.forEach(ojo => ojo.scale.y = THREE.MathUtils.lerp(ojo.scale.y, (blinkTimer < 10) ? 0.1 : 1, 0.3));

    let camDist = keys.r ? -2.5 : (isHeadMode ? 2.5 : 3.5);
    let camY = isHeadMode ? 0.8 : 1.8;
    const camOffset = new THREE.Vector3(0, camY, camDist).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    camera.position.lerp(player.position.clone().add(camOffset), 0.1);
    camera.lookAt(player.position.clone().add(new THREE.Vector3(0, isHeadMode ? 0.2 : 0.8, 0)));
    
    renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
