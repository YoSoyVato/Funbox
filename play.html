<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox - Personaje Blandito</title>
<style>
  body { margin:0; overflow:hidden; background: #a2d2ff; }
  #ui {
    position: fixed; top:20px; left:20px; color:#555;
    font-family: 'Comic Sans MS', cursive, sans-serif; 
    background: rgba(255, 255, 255, 0.8);
    padding:15px; border-radius:20px; z-index:10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
</style>
</head>
<body>

<div id="ui">
  ðŸŒˆ **Â¡Nuevo Amigo Blandito!**<br>
  Â¡Nada de miedo, solo ternura!<br>
  <small>WASD para rebotar por ahÃ­</small>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// 1. ESCENA
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa2d2ff); 
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// LUZ CÃLIDA
const ambient = new THREE.AmbientLight(0xffffff, 0.9);
scene.add(ambient);
const light = new THREE.DirectionalLight(0xffffff, 0.6);
light.position.set(5, 10, 5);
light.castShadow = true;
scene.add(light);

// SUELO DE PASTO CUTE
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(200, 200),
  new THREE.MeshStandardMaterial({color: 0x95d5b2})
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// 2. EL PERSONAJE (SLIME/BLOB)
const player = new THREE.Group();
player.position.y = 0.6;

// Cuerpo principal (Estilo Malvavisco)
const bodyGeo = new THREE.SphereGeometry(0.7, 32, 32);
const bodyMat = new THREE.MeshStandardMaterial({color: 0xffafcc, roughness: 0.3});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.castShadow = true;
player.add(body);

// OJOS (Estilo dibujo animado, no esferas 3D profundas)
const eyeGeo = new THREE.CircleGeometry(0.08, 32);
const eyeMat = new THREE.MeshBasicMaterial({color: 0x222222});
const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
leftEye.position.set(-0.25, 0.1, 0.66);
const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
rightEye.position.set(0.25, 0.1, 0.66);
body.add(leftEye, rightEye);

// MEJILLAS (Solo dos puntitos suaves)
const blushGeo = new THREE.CircleGeometry(0.06, 16);
const blushMat = new THREE.MeshBasicMaterial({color: 0xff8fab, transparent: true, opacity: 0.5});
const lb = new THREE.Mesh(blushGeo, blushMat);
lb.position.set(-0.4, -0.05, 0.64);
const rb = new THREE.Mesh(blushGeo, blushMat);
rb.position.set(0.4, -0.05, 0.64);
body.add(lb, rb);

// MANOS (Esferas pequeÃ±as que flotan a los lados)
const handGeo = new THREE.SphereGeometry(0.15, 16, 16);
const leftHand = new THREE.Mesh(handGeo, bodyMat);
leftHand.position.set(-0.8, -0.2, 0);
const rightHand = new THREE.Mesh(handGeo, bodyMat);
rightHand.position.set(0.8, -0.2, 0);
player.add(leftHand, rightHand);

scene.add(player);

// 3. CONTROLES
const keys = {};
let yaw = 0;
let step = 0;
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => {
  if(document.pointerLockElement) yaw -= e.movementX * 0.003;
});

// 4. ANIMACIÃ“N
function animate() {
  requestAnimationFrame(animate);
  
  let dir = new THREE.Vector3();
  let moving = false;
  if(keys.w) { dir.z -= 1; moving = true; }
  if(keys.s) { dir.z += 1; moving = true; }
  if(keys.a) { dir.x -= 1; moving = true; }
  if(keys.d) { dir.x += 1; moving = true; }

  if(moving) {
    const moveDir = dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    player.position.addScaledVector(moveDir, 0.12);
    player.rotation.y = yaw + Math.PI;
    
    // AnimaciÃ³n de rebote (Squash and Stretch)
    step += 0.2;
    body.scale.y = 1 + Math.sin(step) * 0.1;
    body.scale.x = body.scale.z = 1 - Math.sin(step) * 0.05;
    player.position.y = 0.6 + Math.abs(Math.sin(step)) * 0.3;
    
    // Movimiento de manos
    leftHand.position.y = -0.2 + Math.cos(step) * 0.2;
    rightHand.position.y = -0.2 + Math.sin(step) * 0.2;
  } else {
    // Idle suave (respiraciÃ³n)
    step += 0.05;
    body.scale.y = 1 + Math.sin(step) * 0.03;
    player.position.y = 0.6;
    leftHand.position.y = -0.2 + Math.sin(step) * 0.05;
    rightHand.position.y = -0.2 + Math.sin(step) * 0.05;
    
    // Parpadeo amigable
    if(Math.floor(step * 5) % 30 === 0) {
      leftEye.scale.y = 0.1; rightEye.scale.y = 0.1;
    } else {
      leftEye.scale.y = 1; rightEye.scale.y = 1;
    }
  }

  // CÃ¡mara
  const camPos = new THREE.Vector3(0, 3, 6).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.position.lerp(player.position.clone().add(camPos), 0.1);
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
