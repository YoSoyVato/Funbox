<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox - CilindrÃ­n</title>
<style>
  body { margin:0; overflow:hidden; background: #e0f2f7; } /* Fondo azul cielo suave */
  #ui {
    position: fixed; top:20px; left:20px; color:#333;
    font-family: 'Rubik', sans-serif; /* Fuente moderna y amigable */
    background: rgba(255, 255, 255, 0.9);
    padding:18px; border-radius:15px; z-index:10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 2px solid #a8dadc; 
  }
  @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');
</style>
</head>
<body>

<div id="ui">
  ğŸ”µ **CILINDRÃN: Â¡Listo para la diversiÃ³n!** ğŸˆ<br>
  Â¡Simple, detallado y con estilo!<br>
  <small>WASD para mover | Mouse para mirar</small>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// 1. ESCENA
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xe0f2f7); 
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// LUCES
const ambient = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -10;
dirLight.shadow.camera.right = 10;
dirLight.shadow.camera.top = 10;
dirLight.shadow.camera.bottom = -10;
scene.add(dirLight);

// SUELO SUAVE
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(200, 200),
  new THREE.MeshStandardMaterial({color: 0xcbf1f5}) // Aqua pÃ¡lido
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// 2. EL PERSONAJE: CILINDRÃN
const player = new THREE.Group();
player.position.y = 0.7; // Altura base

// MATERIALES
const mainMat = new THREE.MeshStandardMaterial({
  color: 0x98c1d9, // Azul pastel
  roughness: 0.5,
  metalness: 0.1
});
const accentMat = new THREE.MeshStandardMaterial({
  color: 0xffa07a, // Coral suave
  roughness: 0.6,
  metalness: 0.1
});
const eyeMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 }); // Azul oscuro casi negro
const smileMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 }); // Gris claro

// CUERPO PRINCIPAL (cilindro)
const bodyHeight = 1.0;
const bodyRadiusTop = 0.4;
const bodyRadiusBottom = 0.5; // MÃ¡s ancho en la base
const body = new THREE.Mesh(
  new THREE.CylinderGeometry(bodyRadiusTop, bodyRadiusBottom, bodyHeight, 32),
  mainMat
);
body.castShadow = true;
player.add(body);

// OJOS GRANDES Y BLANCOS
const eyeWhiteGeo = new THREE.SphereGeometry(0.18, 16, 16);
const leftEyeWhite = new THREE.Mesh(eyeWhiteGeo, smileMat);
leftEyeWhite.position.set(-0.2, 0.2, 0.45);
const rightEyeWhite = new THREE.Mesh(eyeWhiteGeo, smileMat);
rightEyeWhite.position.set(0.2, 0.2, 0.45);
body.add(leftEyeWhite, rightEyeWhite);

// PUPILAS (con brillo)
const pupilGeo = new THREE.SphereGeometry(0.08, 16, 16);
const leftPupil = new THREE.Mesh(pupilGeo, eyeMat);
leftPupil.position.z = 0.1;
leftEyeWhite.add(leftPupil);
const rightPupil = new THREE.Mesh(pupilGeo, eyeMat);
rightPupil.position.z = 0.1;
rightEyeWhite.add(rightPupil);

const shineGeo = new THREE.SphereGeometry(0.03, 8, 8);
const shineMat = new THREE.MeshBasicMaterial({color: 0xffffff});
const leftShine = new THREE.Mesh(shineGeo, shineMat);
leftShine.position.set(0.04, 0.04, 0.08);
leftPupil.add(leftShine);
const rightShine = new THREE.Mesh(shineGeo, shineMat);
rightShine.position.set(0.04, 0.04, 0.08);
rightPupil.add(rightShine);

// BOCA (Media esfera para un efecto de sonrisa sutil)
const mouthGeo = new THREE.SphereGeometry(0.15, 16, 16, 0, Math.PI); // Media esfera
const mouth = new THREE.Mesh(mouthGeo, eyeMat);
mouth.rotation.x = Math.PI * 0.5;
mouth.position.set(0, -0.1, 0.48);
body.add(mouth);

// BRAZOS PEQUEÃ‘OS Y REDONDEADOS
const armGeo = new THREE.SphereGeometry(0.15, 16, 16);
const leftArm = new THREE.Mesh(armGeo, accentMat);
leftArm.position.set(-0.6, 0.1, 0);
const rightArm = new THREE.Mesh(armGeo, accentMat);
rightArm.position.set(0.6, 0.1, 0);
player.add(leftArm, rightArm);

scene.add(player);

// 3. CONTROLES Y ANIMACIÃ“N
const keys = {};
let yaw = 0;
let step = 0;
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => {
  if(document.pointerLockElement) yaw -= e.movementX * 0.003;
});

// 4. LOOP DE ANIMACIÃ“N
function animate() {
  requestAnimationFrame(animate);
  
  let dir = new THREE.Vector3();
  let moving = false;
  if(keys.w) { dir.z -= 1; moving = true; }
  if(keys.s) { dir.z += 1; moving = true; }
  if(keys.a) { dir.x -= 1; moving = true; }
  if(keys.d) { dir.x += 1; moving = true; }

  if(moving) {
    const moveDir = dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    player.position.addScaledVector(moveDir, 0.1);
    player.rotation.y = yaw + Math.PI; // El personaje mira hacia donde se mueve
    
    // AnimaciÃ³n de "bamboleo" al moverse
    step += 0.2;
    body.rotation.z = Math.sin(step) * 0.08;
    leftArm.position.y = 0.1 + Math.sin(step) * 0.15;
    rightArm.position.y = 0.1 + Math.sin(step + Math.PI) * 0.15;

  } else {
    // Idle (ligeramente oscilante)
    step += 0.05;
    player.rotation.y = yaw + Math.PI + Math.sin(step * 0.5) * 0.02;
    body.rotation.z = Math.sin(step * 0.2) * 0.02;
    leftArm.position.y = 0.1 + Math.sin(step * 0.1) * 0.05;
    rightArm.position.y = 0.1 + Math.sin(step * 0.1 + Math.PI) * 0.05;

    // Parpadeo sutil
    if (Math.floor(step * 10) % 80 === 0) {
      leftPupil.scale.y = 0.1; rightPupil.scale.y = 0.1;
    } else {
      leftPupil.scale.y = 1; rightPupil.scale.y = 1;
    }
  }

  // Gravedad simple
  if (player.position.y > 0.7) { 
      player.position.y -= 0.02;
  }
  if (player.position.y < 0.7) {
      player.position.y = 0.7; 
  }

  // CÃ¡mara
  const camPos = new THREE.Vector3(0, 2, 4).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.position.lerp(player.position.clone().add(camPos), 0.1);
  camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 0.7, 0))); // Mira al centro del personaje

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
