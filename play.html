<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox - Personaje Ultra Cute</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #ui {
    position: fixed; top:10px; left:10px; color:white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: rgba(255, 105, 180, 0.4); /* Color rosita */
    padding:15px; border-radius:12px; z-index:10;
    backdrop-filter: blur(5px); border: 1px solid white;
  }
</style>
</head>
<body>

<div id="ui">
  ✨ **Funbox: Edición Ternura** ✨<br>
  ¡El personaje ahora es mucho más adorable!<br>
  <small>WASD: Caminar | Shift: Correr | Mouse: Mirar</small>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// 1. ESCENA Y LUCES
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xfff0f5); // Fondo rosa pálido
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Iluminación más suave y clara
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(5, 15, 7);
scene.add(sun);

// SUELO ESTILO PARQUÉ CLARO
const floorSize = 200;
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(floorSize, floorSize),
  new THREE.MeshStandardMaterial({color:0xeeeae3})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// 2. PERSONAJE "ULTRA CUTE"
const player = new THREE.Group();
player.position.set(0,2,0);

// MATERIALES
const mainMat = new THREE.MeshStandardMaterial({color:0xffffff}); // Blanco suave
const accentMat = new THREE.MeshStandardMaterial({color:0xffb6c1}); // Rosa pastel
const eyeMat = new THREE.MeshStandardMaterial({color:0x222222}); 
const blushMat = new THREE.MeshStandardMaterial({color:0xff88aa, transparent: true, opacity: 0.6});

// CUERPO (Más rechoncho y pequeño)
const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), mainMat);
body.scale.set(1, 0.8, 1); // Un poco achatado
body.position.y = 0.6;
player.add(body);

// CABEZA (Grande, estilo Chibi)
const head = new THREE.Mesh(new THREE.SphereGeometry(0.65, 32, 32), mainMat);
head.position.y = 1.4;
player.add(head);

// OREJAS REDONDAS
const earGeo = new THREE.SphereGeometry(0.18, 16, 16);
const leftEar = new THREE.Mesh(earGeo, mainMat);
leftEar.position.set(-0.45, 1.9, 0);
const rightEar = new THREE.Mesh(earGeo, mainMat);
rightEar.position.set(0.45, 1.9, 0);
player.add(leftEar, rightEar);

// OJOS GRANDES Y BRILLANTES
const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
leftEye.position.set(-0.25, 1.5, 0.55);
const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
rightEye.position.set(0.25, 1.5, 0.55);

// Brillo en los ojos (Pixel blanco)
const shineGeo = new THREE.SphereGeometry(0.04, 8, 8);
const shineMat = new THREE.MeshBasicMaterial({color: 0xffffff});
const leftShine = new THREE.Mesh(shineGeo, shineMat);
leftShine.position.set(0.04, 0.04, 0.08);
leftEye.add(leftShine);
const rightShine = new THREE.Mesh(shineGeo, shineMat);
rightShine.position.set(0.04, 0.04, 0.08);
rightEye.add(rightShine);

player.add(leftEye, rightEye);

// MEJILLAS (BLUSH)
const blushGeo = new THREE.CircleGeometry(0.1, 16);
const leftBlush = new THREE.Mesh(blushGeo, blushMat);
leftBlush.position.set(-0.4, 1.35, 0.6);
const rightBlush = new THREE.Mesh(blushGeo, blushMat);
rightBlush.position.set(0.4, 1.35, 0.6);
player.add(leftBlush, rightBlush);

// PATITAS CORTAS
const legGeo = new THREE.CapsuleGeometry(0.12, 0.2, 4, 8);
const leftLeg = new THREE.Mesh(legGeo, accentMat);
leftLeg.position.set(-0.2, 0.15, 0);
const rightLeg = new THREE.Mesh(legGeo, accentMat);
rightLeg.position.set(0.2, 0.15, 0);
player.add(leftLeg, rightLeg);

// BRAZOS PEQUEÑOS
const armGeo = new THREE.CapsuleGeometry(0.08, 0.3, 4, 8);
const leftArm = new THREE.Mesh(armGeo, accentMat);
leftArm.position.set(-0.55, 0.8, 0);
const rightArm = new THREE.Mesh(armGeo, accentMat);
rightArm.position.set(0.55, 0.8, 0);
player.add(leftArm, rightArm);

scene.add(player);

// 3. LÓGICA DE CONTROL
let velY = 0;
const gravity = -0.02;
let yaw=0, pitch=0;
let speed = 0.12;
const keys = {};
let pointerLocked = false;
let step = 0;

window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("pointerlockchange", () => pointerLocked = document.pointerLockElement === document.body);
document.addEventListener("mousemove", e=>{
  if(!pointerLocked) return;
  yaw -= e.movementX*0.002;
});

// 4. LOOP DE ANIMACIÓN
function animate(){
  requestAnimationFrame(animate);

  let dir = new THREE.Vector3();
  let moving = false;
  if(keys.w){dir.z-=1; moving=true;}
  if(keys.s){dir.z+=1; moving=true;}
  if(keys.a){dir.x-=1; moving=true;}
  if(keys.d){dir.x+=1; moving=true;}
  
  let moveSpeed = speed * (keys.shift?1.8:1);
  if(dir.length()>0){
    player.position.addScaledVector(dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw), moveSpeed);
    player.rotation.y = yaw + Math.PI; // El personaje mira hacia donde camina
  }

  // Animaciones Cute
  step += moving ? 0.15 : 0.05;
  
  if(moving){
    // Caminado saltarín
    leftLeg.rotation.x = Math.sin(step)*0.6;
    rightLeg.rotation.x = Math.sin(step+Math.PI)*0.6;
    leftArm.rotation.x = Math.sin(step+Math.PI)*0.4;
    rightArm.rotation.x = Math.sin(step)*0.4;
    player.position.y += Math.abs(Math.sin(step)*0.02); // Pequeño rebote al caminar
  } else {
    // Respiración idle
    head.position.y = 1.4 + Math.sin(step)*0.02;
    leftArm.rotation.z = Math.sin(step)*0.1 - 0.2;
    rightArm.rotation.z = -Math.sin(step)*0.1 + 0.2;
    
    // Parpadeo
    if(Math.floor(step*10) % 40 === 0) {
        leftEye.scale.y = 0.1; rightEye.scale.y = 0.1;
    } else {
        leftEye.scale.y = 1; rightEye.scale.y = 1;
    }
  }

  // Gravedad simple
  velY += gravity;
  player.position.y += velY;
  if(player.position.y < 0){
    player.position.y = 0;
    velY = 0;
  }

  // Cámara suave siguiendo al personaje
  const camOffset = new THREE.Vector3(0, 3, 5).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.position.lerp(player.position.clone().add(camOffset), 0.1);
  camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 1, 0)));

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
