<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Funbox Studio - Play</title>
<style>
  body { margin:0; overflow:hidden; background: #000; }
  #ui {
    position: fixed; top:20px; left:20px; color:#444;
    font-family: 'Arial Rounded MT Bold', sans-serif;
    background: rgba(255, 255, 255, 0.9);
    padding:15px; border-radius:20px; z-index:10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
</style>
</head>
<body>

<div id="ui">
  üì¶üõ†Ô∏è **Funbox Studio**<br>
  WASD: Moverse | **Shift: CORRER** | **C: Agacharse** | **R: C√°mara Frontal**
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// --- CARGAR CONFIGURACI√ìN ---
const config = JSON.parse(localStorage.getItem("funbox_config")) || { 
    floorColor: "#eeeeee", 
    floorSize: 500,
    skyColor: "#87ceeb", 
    ambientIntensity: 0.9 
};

// --- CORRECCI√ìN DE DETECCI√ìN DE SKIN ---
const savedPlayerData = JSON.parse(localStorage.getItem("funbox_player"));
const currentSkin = (savedPlayerData && savedPlayerData.current) ? savedPlayerData.current : (localStorage.getItem("funbox_current_skin") || "juan");
const mapData = JSON.parse(localStorage.getItem("funbox_map")) || [];

const scene = new THREE.Scene();
scene.background = new THREE.Color(config.skyColor);

const fogDensity = config.skyColor === "#1a1a2e" ? 0.05 : 0.01;
scene.fog = new THREE.FogExp2(config.skyColor, fogDensity);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping; 
document.body.appendChild(renderer.domElement);

const hemiLight = new THREE.HemisphereLight(config.skyColor, config.floorColor, 0.6);
scene.add(hemiLight);

const ambient = new THREE.AmbientLight(0xffffff, config.ambientIntensity * 0.5);
scene.add(ambient);

const sunLight = new THREE.DirectionalLight(0xffffff, config.ambientIntensity);
sunLight.position.set(50, 100, 50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);

// --- EL SUELO ---
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(config.floorSize, config.floorSize), 
    new THREE.MeshStandardMaterial({
        color: config.floorColor,
        roughness: 0.8,
        metalness: 0.1
    })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// --- ASSETS ---
function createAssetMesh(type) {
    const group = new THREE.Group();
    const woodMat = new THREE.MeshStandardMaterial({color: 0x5d4037, roughness: 0.7});
    const ironMat = new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.5, roughness: 0.3});
    const fabricMat = new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 1});

    if (type === 'chair') {
        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.5), woodMat);
        seat.position.y = 0.4;
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.08), woodMat);
        back.position.set(0, 0.65, -0.21);
        group.add(seat, back);
        const legGeo = new THREE.BoxGeometry(0.06, 0.4, 0.06);
        for(let x of [-0.2, 0.2]) for(let z of [-0.2, 0.2]) {
            const leg = new THREE.Mesh(legGeo, woodMat);
            leg.position.set(x, 0.2, z);
            group.add(leg);
        }
    } else if (type === 'table') {
        const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.08, 1.2), woodMat);
        top.position.y = 0.75;
        group.add(top);
        const legGeo = new THREE.BoxGeometry(0.1, 0.75, 0.1);
        for(let x of [-0.5, 0.5]) for(let z of [-0.5, 0.5]) {
            const leg = new THREE.Mesh(legGeo, woodMat);
            leg.position.set(x, 0.375, z);
            group.add(leg);
        }
    } else if (type === 'pc') {
        const stand = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 0.2), ironMat);
        const neck = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), ironMat);
        neck.position.y = 0.1;
        const monitor = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.45, 0.05), ironMat);
        monitor.position.y = 0.35;
        const screen = new THREE.Mesh(new THREE.BoxGeometry(0.64, 0.39, 0.01), new THREE.MeshBasicMaterial({color: 0x111111}));
        screen.position.set(0, 0.35, 0.026);
        group.add(stand, neck, monitor, screen);
        group.position.y = 0.79;
    } else if (type === 'bed') {
        const frame = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.2, 2.1), woodMat);
        frame.position.y = 0.15;
        const mattress = new THREE.Mesh(new THREE.BoxGeometry(1, 0.25, 2), fabricMat);
        mattress.position.y = 0.3;
        const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.12, 0.4), fabricMat);
        pillow.position.set(0, 0.45, -0.7);
        const headboard = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.8, 0.1), woodMat);
        headboard.position.set(0, 0.4, -1.05);
        group.add(frame, mattress, pillow, headboard);
    }
    group.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
    return group;
}

// --- CARGA DE BLOQUES Y F√çSICA ---
const physicalBlocks = [];
physicalBlocks.push(floor);
const boxGeo = new THREE.BoxGeometry(1, 1, 1);
const spawnGeo = new THREE.BoxGeometry(1.2, 0.1, 1.2); 
const boxMat = new THREE.MeshStandardMaterial({color: 0x2196f3});
const spawnMat = new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.4});
let spawnPoint = new THREE.Vector3(0, 0, 0);

mapData.forEach(b => {
    let block;
    if (b.type === "spawn") {
        block = new THREE.Mesh(spawnGeo, spawnMat);
        block.position.set(b.x + 0.5, 0.05, b.y + 0.5);
        spawnPoint.set(block.position.x, 0, block.position.z);
        physicalBlocks.push(block);
    } else if (b.type === "block") {
        block = new THREE.Mesh(boxGeo, boxMat);
        block.position.set(b.x + 0.5, 0.5, b.y + 0.5);
        physicalBlocks.push(block);
    } else {
        block = createAssetMesh(b.type);
        block.position.set(b.x + 0.5, 0, b.y + 0.5);
        let hH = (b.type === 'table') ? 0.8 : (b.type === 'bed') ? 0.5 : 1;
        const hitbox = new THREE.Mesh(new THREE.BoxGeometry(0.9, hH, 0.9), new THREE.MeshBasicMaterial({visible: false}));
        hitbox.position.set(b.x + 0.5, hH/2, b.y + 0.5);
        physicalBlocks.push(hitbox);
    }
    scene.add(block);
});

// --- SISTEMA DE COLISIONES ---
function getSurfaceY(pos) {
    let maxY = -100;
    const pR = 0.25; 
    physicalBlocks.forEach(b => {
        if (b === floor) {
            const halfSize = config.floorSize / 2;
            if (pos.x > -halfSize && pos.x < halfSize && pos.z > -halfSize && pos.z < halfSize) maxY = Math.max(maxY, 0);
        } else {
            const bounds = new THREE.Box3().setFromObject(b);
            if (pos.x > bounds.min.x - pR && pos.x < bounds.max.x + pR && pos.z > bounds.min.z - pR && pos.z < bounds.max.z + pR) {
                if (pos.y >= bounds.max.y - 0.25) maxY = Math.max(maxY, bounds.max.y);
            }
        }
    });
    return maxY;
}

function isColliding(pos) {
    const pR = 0.3;
    for (let b of physicalBlocks) {
        if (b === floor) continue;
        const bounds = new THREE.Box3().setFromObject(b);
        if (pos.y < bounds.max.y - 0.1 && pos.y + 1.2 > bounds.min.y) {
            if (pos.x > bounds.min.x - pR && pos.x < bounds.max.x + pR && pos.z > bounds.min.z - pR && pos.z < bounds.max.z + pR) return true;
        }
    }
    return false;
}

// --- PERSONAJE ---
const player = new THREE.Group();
player.position.copy(spawnPoint); 
const cuerpoVisual = new THREE.Group();
player.add(cuerpoVisual);

const listaOjos = [];
let piernaI, piernaD, brazoI, brazoD, cabezaMesh, cabezaGroup, boca;

function buildPlayerModel() {
    const skinPalette = {
        "juan":   { main: 0x5d4037, hair: 0x1a1a1a, skin: 0xffdbac, isGirl: false, isRobot: false },
        "carla":  { main: 0xff66cc, hair: 0x2b1d12, skin: 0xffdbac, isGirl: true, isRobot: false },
        "robot":  { main: 0x444444, hair: 0x00d2ff, skin: 0x222222, isGirl: false, isRobot: true },
        "ninja":  { main: 0x111111, hair: 0x333333, skin: 0xffdbac, isGirl: false, isRobot: false },
        "alien":  { main: 0x33aa33, hair: 0x00ff00, skin: 0x55ff55, isGirl: false, isRobot: false },
        "cat":    { main: 0xffa500, hair: 0xffcc00, skin: 0xffdbac, isGirl: true, isRobot: false }
    };

    const choice = skinPalette[currentSkin] || skinPalette["juan"];
    
    const mats = {
        skin: new THREE.MeshStandardMaterial({color: choice.skin, roughness: choice.isRobot ? 0.2 : 0.4, metalness: choice.isRobot ? 0.7 : 0}),
        main: new THREE.MeshStandardMaterial({color: choice.main, roughness: choice.isRobot ? 0.1 : 0.5, metalness: choice.isRobot ? 0.9 : 0}),
        dark: new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.7}),
        shoes: new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.5}),
        glow: new THREE.MeshBasicMaterial({color: 0x00d2ff})
    };

    cabezaGroup = new THREE.Group();
    cabezaGroup.position.y = 0.82;
    cuerpoVisual.add(cabezaGroup);

    cabezaMesh = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.48, 0.44), mats.main);
    cabezaMesh.castShadow = true;
    cabezaGroup.add(cabezaMesh);

    if (choice.isRobot) {
        // PANTALLA
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.38), new THREE.MeshBasicMaterial({color: 0x000000}));
        screen.position.set(0, 0, 0.222);
        cabezaMesh.add(screen);

        // TORNILLOS LATERALES (OREJAS)
        const boltGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.08, 16);
        boltGeo.rotateZ(Math.PI/2);
        const boltL = new THREE.Mesh(boltGeo, mats.main);
        boltL.position.set(-0.25, 0, 0);
        const boltR = new THREE.Mesh(boltGeo, mats.main);
        boltR.position.set(0.25, 0, 0);
        cabezaMesh.add(boltL, boltR);

        // ANTENAS INCLINADAS
        function createAntenna(x, rot) {
            const g = new THREE.Group();
            const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.18), mats.main);
            rod.position.y = 0.09;
            const tip = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), mats.glow);
            tip.position.y = 0.18;
            g.add(rod, tip);
            g.position.set(x, 0.24, 0);
            g.rotation.z = rot;
            return g;
        }
        cabezaMesh.add(createAntenna(-0.12, 0.3), createAntenna(0.12, -0.3));

        // OJOS LED
        function createLedEye(x) {
            const eye = new THREE.Mesh(new THREE.CircleGeometry(0.065, 32), new THREE.MeshBasicMaterial({color: 0xffffff}));
            eye.position.set(x, 0.05, 0.225);
            listaOjos.push(eye);
            return eye;
        }
        cabezaMesh.add(createLedEye(-0.12), createLedEye(0.12));

        // BOCA LED
        const bocaLed = new THREE.Mesh(new THREE.PlaneGeometry(0.18, 0.035), mats.glow);
        bocaLed.position.set(0, -0.12, 0.225);
        cabezaMesh.add(bocaLed);
        boca = bocaLed;

    } else {
        // DISE√ëO HUMANO
        const bocaGeo = new THREE.PlaneGeometry(0.12, 0.08);
        const bocaMat = new THREE.MeshBasicMaterial({color: 0x000000, transparent: true, opacity: 0.8, side: THREE.DoubleSide});
        boca = new THREE.Mesh(bocaGeo, bocaMat);
        boca.position.set(0, -0.12, 0.222); 
        cabezaMesh.add(boca);

        const hairGroup = new THREE.Group();
        const hairMat = new THREE.MeshStandardMaterial({color: choice.hair, roughness: 0.8});
        if (!choice.isGirl) {
            const topHair = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.15, 0.48), hairMat);
            topHair.position.y = 0.2;
            hairGroup.add(topHair);
            const bangsGeo = new THREE.BoxGeometry(0.1, 0.12, 0.1);
            for(let i = 0; i < 5; i++) {
                const bang = new THREE.Mesh(bangsGeo, hairMat);
                bang.position.set(-0.18 + (i * 0.09), 0.18, 0.22);
                bang.rotation.x = 0.4;
                hairGroup.add(bang);
            }
        } else {
            const topHair = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.2, 0.48), hairMat);
            topHair.position.set(0, 0.18, 0);
            hairGroup.add(topHair);
            const backHair = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.5, 0.25), hairMat);
            backHair.position.set(0, -0.05, -0.12);
            hairGroup.add(backHair);
            const fringe = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.15, 0.05), hairMat);
            fringe.position.set(0, 0.18, 0.22);
            fringe.rotation.z = -0.05;
            hairGroup.add(fringe);
            const bun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), hairMat);
            bun.position.set(0, 0.15, -0.28);
            hairGroup.add(bun);
        }
        cabezaMesh.add(hairGroup);

        function createEye(x) {
            const eyeGroup = new THREE.Group();
            const orb = new THREE.Mesh(new THREE.CircleGeometry(0.08, 32), new THREE.MeshBasicMaterial({color: 0x000000}));
            const shine1 = new THREE.Mesh(new THREE.CircleGeometry(0.03, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
            shine1.position.set(0.025, 0.025, 0.01); 
            const shine2 = new THREE.Mesh(new THREE.CircleGeometry(0.012, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
            shine2.position.set(-0.02, -0.03, 0.01); 
            eyeGroup.add(orb, shine1, shine2);
            eyeGroup.position.set(x, -0.04, 0.221);
            listaOjos.push(eyeGroup);
            return eyeGroup;
        }
        cabezaMesh.add(createEye(-0.13), createEye(0.13));
    }

    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.5, 0.24), mats.main);
    torso.position.y = 0.45;
    cuerpoVisual.add(torso);

    // JETPACK Y N√öCLEO (Solo para el Robot)
    if (choice.isRobot) {
        const jetpack = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.38, 0.15), mats.main);
        jetpack.position.set(0, 0.45, -0.18);
        cuerpoVisual.add(jetpack);
        
        const core = new THREE.Mesh(new THREE.CircleGeometry(0.08, 32), mats.glow);
        core.position.set(0, 0.48, 0.121);
        cuerpoVisual.add(core);
    }

    const armGeo = new THREE.CapsuleGeometry(0.07, 0.2, 8, 10);
    function createArm(x) {
        const g = new THREE.Group();
        const arm = new THREE.Mesh(armGeo, mats.main);
        const hand = new THREE.Mesh(new THREE.SphereGeometry(0.075, 12, 12), mats.skin);
        hand.position.y = -0.15;
        g.add(arm, hand);
        g.position.set(x, 0.55, 0);
        return g;
    }
    brazoI = createArm(-0.28);
    brazoD = createArm(0.28);
    cuerpoVisual.add(brazoI, brazoD);

    const legGeo = new THREE.CapsuleGeometry(0.085, 0.22, 8, 10);
    legGeo.translate(0, -0.11, 0); 
    function createLeg(x) {
        const g = new THREE.Group();
        const leg = new THREE.Mesh(legGeo, mats.dark);
        const boot = new THREE.Mesh(new THREE.BoxGeometry(0.19, 0.12, 0.26), mats.shoes);
        boot.position.set(0, -0.25, 0.04);
        g.add(leg, boot);
        g.position.set(x, 0.35, 0);
        return g;
    }
    piernaI = createLeg(-0.12);
    piernaD = createLeg(0.12);
    cuerpoVisual.add(piernaI, piernaD);
}
buildPlayerModel();
scene.add(player);

// --- L√ìGICA ---
let vy = 0, onGround = true, isHeadMode = false;
const gravity = -0.015, jumpForce = 0.3;
const keys = {};
let yaw = 0, pitch = 0, step = 0, rollStep = 0, blinkTimer = 0;

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if(e.code === "Space" && onGround) vy = jumpForce;
    if(e.key.toLowerCase() === "c" && onGround) isHeadMode = !isHeadMode;
});
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => { 
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.003;
        pitch -= e.movementY * 0.003;
        pitch = Math.max(-0.5, Math.min(0.5, pitch));
    }
});

function animate() {
    requestAnimationFrame(animate);
    const currentSurfaceY = getSurfaceY(player.position);
    
    player.position.y += vy;
    if (player.position.y > currentSurfaceY) { vy += gravity; onGround = false; }
    else { 
        if (currentSurfaceY > -50) { 
            player.position.y = currentSurfaceY; 
            vy = Math.max(0, vy); 
            onGround = true; 
        } else { 
            onGround = false; vy += gravity; 
        }
    }

    let isFallingDeep = player.position.y < -2;
    if (isFallingDeep) {
        player.rotation.x += 0.2; 
        player.rotation.z += 0.1;
        if(boca) boca.scale.set(1.5, 4, 1);
    } else {
        player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, 0, 0.1);
        player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);
    }

    if (player.position.y < -15) { 
        player.position.copy(spawnPoint); 
        player.position.y = 5; vy = 0; 
        player.rotation.set(0,0,0);
    }

    let moving = false, dir = new THREE.Vector3();
    if(keys.w){ dir.z -= 1; moving = true; }
    if(keys.s){ dir.z += 1; moving = true; }
    if(keys.a){ dir.x -= 1; moving = true; }
    if(keys.d){ dir.x += 1; moving = true; }

    let isRunning = keys.shift && moving;
    let moveSpeed = isHeadMode ? 0.12 : (isRunning ? 0.18 : 0.09);
    let animationSpeed = isRunning ? 0.4 : 0.2;
    player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, yaw + Math.PI, 0.15);

    if(boca) {
        if (!onGround && !isFallingDeep) {
            boca.scale.set(1.8, 2.0, 1); 
        } else if (moving) {
            if (isRunning) {
                let vibrate = Math.sin(Date.now() * 0.03) * 0.2;
                boca.scale.set(2.2 + vibrate, 0.5, 1);
            } else {
                boca.scale.set(1.2, 0.7, 1);
            }
        } else {
            let breathe = Math.sin(Date.now() * 0.002) * 0.1 + 0.3;
            boca.scale.set(1, breathe, 1);
        }
    }

    if(moving) {
        const moveDir = dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        const nextPos = player.position.clone().add(moveDir.multiplyScalar(moveSpeed));
        if (!isColliding(nextPos)) { player.position.x = nextPos.x; player.position.z = nextPos.z; }
        
        if (!isHeadMode && onGround) {
            step += animationSpeed;
            piernaI.rotation.x = Math.sin(step) * 0.6;
            piernaD.rotation.x = Math.sin(step + Math.PI) * 0.6;
            brazoI.rotation.x = Math.sin(step + Math.PI) * 0.6;
            brazoD.rotation.x = Math.sin(step) * 0.6;
            cuerpoVisual.position.y = Math.abs(Math.sin(step)) * 0.05;
        } else if (isHeadMode) {
            rollStep += 0.15;
            cabezaMesh.rotation.x = -rollStep; 
        }
    } else {
        cabezaMesh.rotation.x = THREE.MathUtils.lerp(cabezaMesh.rotation.x, 0, 0.1);
        [piernaI, piernaD, brazoI, brazoD].forEach(p => p.rotation.x = THREE.MathUtils.lerp(p.rotation.x, 0, 0.1));
        cuerpoVisual.position.y = THREE.MathUtils.lerp(cuerpoVisual.position.y, 0, 0.1);
    }

    if (!onGround && !isFallingDeep) {
        cuerpoVisual.scale.y = THREE.MathUtils.lerp(cuerpoVisual.scale.y, 1.15, 0.1);
        cuerpoVisual.scale.x = THREE.MathUtils.lerp(cuerpoVisual.scale.x, 0.85, 0.1);
    } else {
        cuerpoVisual.scale.y = THREE.MathUtils.lerp(cuerpoVisual.scale.y, 1, 0.2);
        cuerpoVisual.scale.x = THREE.MathUtils.lerp(cuerpoVisual.scale.x, 1, 0.2);
    }

    if (isHeadMode) {
        cuerpoVisual.children.forEach(c => { if(c !== cabezaGroup) c.scale.set(0.001,0.001,0.001); });
        cabezaGroup.position.y = THREE.MathUtils.lerp(cabezaGroup.position.y, 0.3, 0.15);
    } else {
        cuerpoVisual.children.forEach(c => c.scale.set(1,1,1));
        cabezaGroup.position.y = THREE.MathUtils.lerp(cabezaGroup.position.y, 0.82, 0.15);
    }

    blinkTimer--;
    if (blinkTimer < 0) blinkTimer = Math.random() * 300 + 100;
    listaOjos.forEach(ojo => { 
        ojo.scale.y = (blinkTimer < 10) ? 0.1 : 1; 
    });

    let camDist = keys.r ? -2.5 : (isHeadMode ? 2.2 : 3.0);
    const camOffset = new THREE.Vector3(0, isHeadMode ? 0.6 : 1.4, camDist).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    camera.position.lerp(player.position.clone().add(camOffset), 0.1);
    camera.lookAt(player.position.clone().add(new THREE.Vector3(0, isHeadMode ? 0.2 : 0.7, 0)));
    renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
