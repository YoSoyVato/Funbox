<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Estados Espa침oles - Prototipo RP (Cute)</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #ui {
    position: fixed; top:10px; left:10px; color:white;
    font-family: Arial; background: rgba(0,0,0,0.6);
    padding:10px; border-radius:8px; z-index:10;
  }
</style>
</head>
<body>

<div id="ui">
  游꿡 **Modo Cute Diagn칩stico**<br>
  El personaje ahora es m치s tierno 游땘<br>
  WASD: Moverse | Shift: Correr | Mouse: C치mara
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// 1. ESCENA
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(10,20,10);
scene.add(sun);

// SUELO (200x200)
const floorSize = 200;
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(floorSize, floorSize),
  new THREE.MeshStandardMaterial({color:0x555555})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// 2. PERSONAJE CUTE
const player = new THREE.Group();
player.position.set(0,5,0);

// MATERIAL PRINCIPAL (colores pastel)
const bodyMat = new THREE.MeshStandardMaterial({color:0x77ddff});
const limbMat = new THREE.MeshStandardMaterial({color:0x77ddff});
const eyeMat = new THREE.MeshStandardMaterial({color:0x000000});

// CUERPO (corto y gordito)
const bodyHeight = 1.0;
const bodyRadius = 0.5;
const body = new THREE.Mesh(new THREE.CapsuleGeometry(bodyRadius, bodyHeight, 4, 8), bodyMat);
body.position.y = bodyHeight/2 + 0.5;
player.add(body);

// CABEZA (grande y redonda)
const head = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), bodyMat);
head.position.y = body.position.y + bodyHeight/2 + 0.6;
player.add(head);

// OJOS GRANDES Y SIMPLES
const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8), eyeMat);
leftEye.position.set(-0.2, head.position.y+0.1, 0.55);
const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8), eyeMat);
rightEye.position.set(0.2, head.position.y+0.1, 0.55);
player.add(leftEye, rightEye);

// PIERNAS CORTAS
const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.4,6);
const leftLeg = new THREE.Mesh(legGeo, limbMat);
leftLeg.position.set(-0.15,0.2,0);
const rightLeg = new THREE.Mesh(legGeo, limbMat);
rightLeg.position.set(0.15,0.2,0);
player.add(leftLeg,rightLeg);

// BRAZOS PEQUE칌OS
const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.5,6);
const leftArm = new THREE.Mesh(armGeo, limbMat);
leftArm.position.set(-0.55,body.position.y,0);
const rightArm = new THREE.Mesh(armGeo, limbMat);
rightArm.position.set(0.55,body.position.y,0);
player.add(leftArm,rightArm);

scene.add(player);

// 3. VARIABLES
let velY = 0;
const gravity = -0.03;
let yaw=0, pitch=0;
let speed = 0.15;
const keys = {};
let pointerLocked = false;
let step = 0;
let blinkTimer = 0;

window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("pointerlockchange", () => pointerLocked = document.pointerLockElement === document.body);
document.addEventListener("mousemove", e=>{
  if(!pointerLocked) return;
  yaw -= e.movementX*0.002; pitch -= e.movementY*0.002; pitch = Math.max(-0.6, Math.min(0.6, pitch));
});

// 4. LOOP PRINCIPAL
function animate(){
  requestAnimationFrame(animate);

  // Movimiento
  let dir = new THREE.Vector3();
  let moving = false;
  if(keys.w){dir.z-=1; moving=true;}
  if(keys.s){dir.z+=1; moving=true;}
  if(keys.a){dir.x-=1; moving=true;}
  if(keys.d){dir.x+=1; moving=true;}
  let moveSpeed = speed * (keys.shift?2:1);
  if(dir.length()>0) player.position.addScaledVector(dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw), moveSpeed);

  step += 0.1;

  // Animaci칩n de piernas y brazos
  if(moving){
    leftLeg.rotation.x = Math.sin(step)*0.4;
    rightLeg.rotation.x = Math.sin(step+Math.PI)*0.4;
    leftArm.rotation.x = Math.sin(step+Math.PI)*0.3;
    rightArm.rotation.x = Math.sin(step)*0.3;

    // Ojos abiertos mientras se mueve
    leftEye.scale.y = 1;
    rightEye.scale.y = 1;
  } else {
    // Pose idle suave
    leftLeg.rotation.x = Math.sin(step*0.05)*0.05;
    rightLeg.rotation.x = Math.sin(step*0.05+Math.PI)*0.05;
    leftArm.rotation.x = Math.sin(step*0.05+Math.PI)*0.02;
    leftArm.rotation.z = Math.sin(step*0.05+Math.PI)*0.02;
    rightArm.rotation.x = Math.sin(step*0.05)*0.02;
    rightArm.rotation.z = Math.sin(step*0.05)*0.02;

    // Ojos parpadeo idle
    blinkTimer++;
    if(blinkTimer % 100 < 5){
      leftEye.scale.y = 0.1;
      rightEye.scale.y = 0.1;
    } else {
      leftEye.scale.y = 1;
      rightEye.scale.y = 1;
    }
  }

  // F칈SICAS
  velY += gravity;
  player.position.y += velY;

  // L칈MITES DEL MAPA
  const limite = floorSize / 2; 
  const estaDentro = Math.abs(player.position.x) <= limite && Math.abs(player.position.z) <= limite;

  if(estaDentro){
      // DENTRO DEL MAPA
      bodyMat.color.set(0x77ddff);
      limbMat.color.set(0x77ddff);
  } else {
      // FUERA DEL MAPA
      bodyMat.color.set(0xff5555);
      limbMat.color.set(0xff5555);
  }

  // Colisi칩n con suelo
  if(estaDentro && player.position.y <= bodyHeight/2 + 0.5){
      player.position.y = bodyHeight/2 + 0.5;
      velY = 0;
  }

  // Respawn
  if(player.position.y < -50){ player.position.set(0,10,0); velY = 0; }

  // C치mara
  const camOffset = new THREE.Vector3(0,2,6).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.position.copy(player.position).add(camOffset);
  camera.lookAt(player.position.clone().add(new THREE.Vector3(0, bodyHeight/2 + 0.5, 0)));

  renderer.render(scene,camera);
}
animate();

// REAJUSTE DE VENTANA
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
